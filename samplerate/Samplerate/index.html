<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Samplerate (samplerate.Samplerate)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">samplerate</a> &#x00BB; Samplerate</nav><header class="odoc-preamble"><h1>Module <code><span>Samplerate</span></code></h1><p>Bindings for libsamplerate library, which is dedicated to changing the sampling rate of audio data. All offsets and sizes are given in number of samples <i>per channel</i>.</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Samuel Mimram</li></ul></header><nav class="odoc-toc"><ul><li><a href="#simple-api">Simple API</a></li><li><a href="#full-api">Full API</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-converter"><a href="#type-converter" class="anchor"></a><code><span><span class="keyword">type</span> converter</span><span> = </span></code><ol><li id="type-converter.Conv_sinc_best_quality" class="def variant constructor anchored"><a href="#type-converter.Conv_sinc_best_quality" class="anchor"></a><code><span>| </span><span><span class="constructor">Conv_sinc_best_quality</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>This is a bandlimited interpolator derived from the mathematical sinc function and this is the highest quality sinc based converter, providing a worst case Signal-to-Noise Ratio (SNR) of 97 decibels (dB) at a bandwidth of 97%. All three Conv_sinc_* converters are based on the techniques of Julius O. Smith although this code was developed independantly.</p><span class="comment-delim">*)</span></div></li><li id="type-converter.Conv_sinc_medium_quality" class="def variant constructor anchored"><a href="#type-converter.Conv_sinc_medium_quality" class="anchor"></a><code><span>| </span><span><span class="constructor">Conv_sinc_medium_quality</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>This is another bandlimited interpolator much like the previous one. It has an SNR of 97dB and a bandwidth of 90%. The speed of the conversion is much faster than the previous one.</p><span class="comment-delim">*)</span></div></li><li id="type-converter.Conv_fastest" class="def variant constructor anchored"><a href="#type-converter.Conv_fastest" class="anchor"></a><code><span>| </span><span><span class="constructor">Conv_fastest</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>This is the fastest bandlimited interpolator and has an SNR of 97dB and a bandwidth of 80%.</p><span class="comment-delim">*)</span></div></li><li id="type-converter.Conv_zero_order_hold" class="def variant constructor anchored"><a href="#type-converter.Conv_zero_order_hold" class="anchor"></a><code><span>| </span><span><span class="constructor">Conv_zero_order_hold</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A Zero Order Hold converter (interpolated value is equal to the last value). The quality is poor but the conversion speed is blindlingly fast.</p><span class="comment-delim">*)</span></div></li><li id="type-converter.Conv_linear" class="def variant constructor anchored"><a href="#type-converter.Conv_linear" class="anchor"></a><code><span>| </span><span><span class="constructor">Conv_linear</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A linear converter. Again the quality is poor, but the conversion speed is blindingly fast.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Kind of converter.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_conv_name"><a href="#val-get_conv_name" class="anchor"></a><code><span><span class="keyword">val</span> get_conv_name : <span><a href="#type-converter">converter</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Name of a converter.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_conv_descr"><a href="#val-get_conv_descr" class="anchor"></a><code><span><span class="keyword">val</span> get_conv_descr : <span><a href="#type-converter">converter</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Description of a converter.</p></div></div><h3 id="simple-api"><a href="#simple-api" class="anchor"></a>Simple API</h3><div class="odoc-spec"><div class="spec value anchored" id="val-convert"><a href="#val-convert" class="anchor"></a><code><span><span class="keyword">val</span> convert : 
  <span><a href="#type-converter">converter</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span><span>float array</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>float array</span></span></code></div><div class="spec-doc"><p><code>convert converter channels ratio inbuf offset length</code> converts audio data with given number of channels with the given ratio (output samplerate / input samplerate) reading from given buffer starting at given offset, the given number of audio samples (per channel).</p></div></div><h3 id="full-api"><a href="#full-api" class="anchor"></a>Full API</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Internal state for a converter.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><a href="#type-converter">converter</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a converter of given kind with given number of channels.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-process"><a href="#val-process" class="anchor"></a><code><span><span class="keyword">val</span> process : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span><span>float array</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>float array</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  int * int</span></code></div><div class="spec-doc"><p>Convert audio data with given state, at given ratio, reading from given buffer at given offset the given number of samples, writing in output buffer starting at offset the given number of samples. Returns the number of samples (per channel) used from input buffer and produced in output buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-process_ba"><a href="#val-process_ba" class="anchor"></a><code><span><span class="keyword">val</span> process_ba : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="xref-unresolved">Stdlib</span>.Bigarray.float32_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="xref-unresolved">Stdlib</span>.Bigarray.float32_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span> <span class="arrow">&#45;&gt;</span></span>
  int * int</span></code></div><div class="spec-doc"><p>Similar to <code>process</code> but takes bigarrays to store audio data.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-process_alloc"><a href="#val-process_alloc" class="anchor"></a><code><span><span class="keyword">val</span> process_alloc : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><span>float array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>float array</span></span></code></div><div class="spec-doc"><p>Similar to <code>process</code> but allocates a new buffer instead of writing in a specified output buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span><span class="keyword">val</span> reset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Reset the state of the encoder.</p></div></div></div></body></html>